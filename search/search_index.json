{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"django-grainy Granular permissions for django Supported Django Versions Django 3.2 Django 4.0 Django 4.2 Documentation https://20c.github.io/django-grainy License Copyright 2019-2023 20C, LLC Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this softare except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Home"},{"location":"#django-grainy","text":"Granular permissions for django","title":"django-grainy"},{"location":"#supported-django-versions","text":"Django 3.2 Django 4.0 Django 4.2","title":"Supported Django Versions"},{"location":"#documentation","text":"https://20c.github.io/django-grainy","title":"Documentation"},{"location":"#license","text":"Copyright 2019-2023 20C, LLC Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this softare except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"examples/","text":"Managing user permissions A user gets his permissions directly or from one of the auth Groups he is a member of Setting permissions import grainy.const # literal namespace with integer permission flag user.grainy_permissions.add_permission(\"a.b.c\", grainy.const.READ) # literal namespace with string permission flag user.grainy_permissions.add_permission(\"a.b.c\", \"r\") # same for groups group.grainy_permissions.add_permission(\"a.b.c\", \"r\") Setting permissions in bulk import grainy.const import grainy.core # set from PermissionSet instance user.grainy_permissions.add_permission_set( grainy.core.PermissionSet({\"a.b.c\": grainy.const.PERM_READ}) ) # set from dict (allows string permissions) user.grainy_permissions.add_permission_set({\"a.b.c\": \"r\"}) Checking permissions import grainy.const from django_grainy.util import Permissions user.grainy_permissions.add_permission_set({\"a.b.c\": \"r\"}) # we use the Permissions() wrapper as that allows # us to do repeated permission checks for a user or group # without having requery permissions for each check perms = Permissions(user) perms.check(\"a.b.c\", grainy.const.PERM_READ) # True perms.check(\"a.b.c.d\", grainy.const.PERM_READ) # True perms.check(\"a.b.c.d\", grainy.const.PERM_READ | grainy.const.PERM_UPDATE) # False perms.check(\"z.y.x\", grainy.const.PERM_READ) # False perms.check(\"a.b.c\", \"r\") # True perms.check(\"a.b.c.d\", \"r\") # True perms.check(\"a.b.c.d\", \"ru\") # False perms.check(\"x.y.z\", \"r\") # False # The `explicit` option allows us to require that excplicit # permissions need to exist for a check to succeed, meaning # having permissions to `a.b.c` will not grant permissions # to `a.b.c.d` if `explicit`=True perms.check(\"a.b.c.d\", \"r\", explicit=True) # False Custom permission holders Sometimes you want something else than a user or group model to hold permissions - an APIkey implementation for example from django.db import models from django_grainy.models import Permission, PermissionManager class APIKey(models.Model): key = models.CharField(max_length=255) class APIKeyPermission(Permission): # The `grainy_permissions` related name is important # so that we can pass instances of this model to # util.Permissions api_key = models.ForeignKey( APIKey, related_name=\"grainy_permissions\", on_delete=models.CASCADE ) # use the augmented object manager for permission handling objects = PermissionManager() from django_grainy.util import Permissions api_key = APIKey.objects.create(key=\"test\") api_key.grainy_permissions.add_permission(\"a.b.c\", \"r\") perms = Permissions(api_key) assert api_key.check(\"a.b.c\", \"r\") Grainy Models A django model can be initialized for grainy permissions using the grainy_model decorator. from django.db import models from grainy.decorators import grainy_model # initialize grainy permissions for a model # with automatic namespacing @grainy_model() class TestModelA(models.Model): name = models.CharField(max_length=255) # initialize grainy permissions for a model # with manual namespacing @grainy_model(namespace=\"a.b.c\") class TestModelB(models.Model): name = models.CharField(max_length=255) # initialize grainy permissions for a model # with manual namespacing for both class # and instance namespace @grainy_model( # we want the same base namespace as model b namespace=TestModelB.Grainy.namespace(), # when checking against instances we want to # nest inside b namespace_instance=\"{namespace}.{instance.b.id}.b.{instance.id}\", ) class TestModelC(models.Model): b = models.ForeignKey(TestModelB) Afterwards the model can be used directly to set or check permissions to it from django_grainy.util import Permissions # give user full permissions to model (any instance) user.grainy_permissions.add(TestModelA, \"crud\") # give user full permissions to a specific instance instance = TestModelA.objects.get(id=1) user.grainy_permissions.add(instance, \"crud\") # check user permission on model class perms = Permissions(user) perms.check(TestModelA, \"r\") # True # check user permission on instance perms.check(instance, \"r\") # True # check permissions to the name field perms.check((instance, \"name\"), \"r\") # return all instances of the model according to permissions instances = perms.instances(TestModelA, \"r\") # this could also take a queryset instances_from_qset = perms.instances(TestModelA.objects.filter(id__gt=10), \"r\") In the grainy_model decorator you can also specify if you want grainy to treat the model as a child of another grainy model by using the parent parameter. This allows you to quickly chain namespaces with the child getting it's namespace prefixed with the parent's namespace # starting with 1.7 you can also use the `parent` argument # to quickly setup namespace inheritance for models @grainy_model(namespace=\"x\") class ModelX(ModelA): pass # We set parent to `x`, to indicate that we want to inherit # the namespacing from there. It needs to point to ForeignKey or OneToOne # field on the model that points to a model that is also grainy (ModelX # in this example) # # ModelY will end up with the following instance namespace: # \"x.{x.pk}.custom.{pk}\" @grainy_model(namespace=\"custom\", parent=\"x\") class ModelY(ModelA): # field name == grainy `parent` value x = models.ForeignKey(ModelX, related_name=\"y\", on_delete=models.CASCADE) # ModelZ will end up with the following instance namespace: # \"x.{y.x.pk}.custom.{y.pk}.z.{pk}\" @grainy_model(namespace=\"z\", parent=\"y\") class ModelZ(ModelA): # field name == grainy `parent` value y = models.ForeignKey(ModelY, related_name=\"z\", on_delete=models.CASCADE) Grainy views A django view can be initialized for grainy permissions using the grainy_view decorator. When a view is made grainy it will automatically check for apropriate permissions to the specified namespace depending on the request method. from django.views import View as BaseView from django_grainy.decorators import grainy_view # grainy function view @grainy_view(namespace=\"a.b.c\") def view(request): return HttpResponse() # grainy class view @grainy_view(namespace=\"a.b.c\") class View(BaseView): # will check for READ perms to \"a.b.c\", otherwise fails with 403 def get(self, request): return HttpResonse() # will check for CREATE perms to \"a.b.c\", otherwise fails with 403 def post(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 def put(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 def patch(self, request): return HttpResponse() # will check for DELETE perms to \"a.b.c\", otherwise fails with 403 def delete(self, request): return HttpResponse() # grainy view with formatted namespace @grainy_view(namespace=\"detail.{id}\") def detail_view(request, id): return HttpResponse() # you can also pass through flags for permissions checks @grainy_view( namespace=\"detail.{id}\", # require that the user has explicitly set permissions for the namespace explicit=True, # ignore the user's superuser priviledges ignore_grant_all=True, ) def detail_view(request, id): return HttpResponse() Manually decorate view response handlers The grainy_view decorator simply calls the apropriate response decorator on all the response handlers in the view. It follows that from django.views import BaseView from django_grainy.decorators import grainy_view # grainy class view @grainy_view(namespace=\"a.b.c\") class View(BaseView): # will check for READ perms to \"a.b.c\", otherwise fails with 403 def get(self, request): return HttpResonse() # will check for CREATE perms to \"a.b.c\", otherwise fails with 403 def post(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 def put(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 def patch(self, request): return HttpResponse() # will check for DELETE perms to \"a.b.c\", otherwise fails with 403 def delete(self, request): return HttpResponse() is the same as from django.views import BaseView from django_grainy.decorators import grainy_view_response # grainy class view class View(BaseView): # will check for READ perms to \"a.b.c\", otherwise fails with 403 @grainy_view_response(namespace=\"a.b.c\") def get(self, request): return HttpResonse() # will check for CREATE perms to \"a.b.c\", otherwise fails with 403 @grainy_view_response(namespace=\"a.b.c\") def post(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 @grainy_view_response(namespace=\"a.b.c\") def put(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 @grainy_view_response(namespace=\"a.b.c\") def patch(self, request): return HttpResponse() # will check for DELETE perms to \"a.b.c\", otherwise fails with 403 @grainy_view_response(namespace=\"a.b.c\") def delete(self, request): return HttpResponse() You may also use both decorators from django.views import BaseView from django_grainy.decorators import grainy_view, grainy_view_response # grainy class view @grainy_view(namespace=\"a.b.c\") class View(BaseView): # will check for READ perms to \"a.b.c\", otherwise fails with 403 def get(self, request): return HttpResonse() # will check for CREATE perms to \"x.y.z\", otherwise fails with 403 @grainy_view_response(namespace=\"x.y.z\") def post(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 def put(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 def patch(self, request): return HttpResponse() # will check for DELETE perms to \"a.b.c\", otherwise fails with 403 def delete(self, request): return HttpResponse() Rest Framework Integration Use the grainy_rest_viewset decorator to apply grainy permissions to the output of a django_rest_framework ViewSet. This means any content that the user does not have permission to view will be dropped from the api response. from rest_framework import serializers from django_grainy.decorators import grainy_rest_viewset from .models import TestModelA # A serializer to test with class ModelASerializer(serializers.HyperlinkedModelSerializer): # to test applying of permissions in nested data nested_dict = serializers.SerializerMethodField(required=False) class Meta: model = TestModelA fields = (\"name\", \"id\", \"nested_dict\") def get_nested_dict(self, obj): return {\"secret\": {\"hidden\": \"data\"}, \"something\": \"public\"} @grainy_rest_viewset( namespace=\"api.a\", handlers={ # with application handlers we can tell grainy that this # namespace needs to have explicit permissions in order # to be accessed \"nested_dict.secret\": {\"explicit\": True} }, ) class ModelAViewSet(viewsets.ModelViewSet): queryset = TestModelA.objects.all() serializer_class = ModelASerializer A user with READ permissions to api.a accessing this rest viewset would get this response [{\"name\":\"Test model 1\",\"id\":1,\"nested_dict\":{\"something\":\"public\"}}] While a user with READ permissions to api.a and READ permissions to api.a.*.nested_dict.secret would get this response [{\"name\":\"Test model 1\",\"id\":1,\"nested_dict\":{\"secret\":{\"hidden\":\"data\"},\"something\":\"public\"}}] Remote permission provider This functionality is still a work in progress and subject to change. Here is a quick and dirty example on how to set up a django project to be a remote grainy permission provider for another django project. provider Set up the grainy endpoints on the grainy permission provider instance from django_grainy.remote import Authenticator, ProvideGet, ProvideLoad class GrainyRequestAuthenticator(Authenticator): def authenticate(self, request): # pseudo-code for handling a token authentication handle_token_authentication(request) urlpatterns += [ # grainy path( \"grainy/get/<str:namespace>/\", ProvideGet.as_view(authenticator_cls=GrainyRequestAuthenticator), name=\"grainy-get\", ), path( \"grainy/load/\", ProvideLoad.as_view(authenticator_cls=GrainyRequestAuthenticator), name=\"grainy-load\", ), ] For the sake of this example it is assumed that the provider instance runs at localhost:8000 receiver In order to correctly setup authentication from the receiver django instance the provider django instance you will want to implement an authentication protocol. In this example we go with a straight forward token authentication. Note that the actual authentication logic is omitted as that is not really in the scope of this example. from django.conf import settings import django_grainy.remote class RemotePermissions(django_grainy.remote.Permissions): def __init__(self, obj): super().__init__( obj, url_load=\"http://localhost:8000/grainy/load\", url_get=\"http://localhost:8000/grainy/get\", ) def prepare_request(self, params, headers): try: key = self.obj.key_set.first().key headers.update(Authorization=f\"token {key}\") except AttributeError: pass Then use it like you would the normal Permissions util perms = RemotePermissions(user) perms.check(\"a.b.c\", PREAM_READ)","title":"Examples"},{"location":"examples/#managing-user-permissions","text":"A user gets his permissions directly or from one of the auth Groups he is a member of","title":"Managing user permissions"},{"location":"examples/#setting-permissions","text":"import grainy.const # literal namespace with integer permission flag user.grainy_permissions.add_permission(\"a.b.c\", grainy.const.READ) # literal namespace with string permission flag user.grainy_permissions.add_permission(\"a.b.c\", \"r\") # same for groups group.grainy_permissions.add_permission(\"a.b.c\", \"r\")","title":"Setting permissions"},{"location":"examples/#setting-permissions-in-bulk","text":"import grainy.const import grainy.core # set from PermissionSet instance user.grainy_permissions.add_permission_set( grainy.core.PermissionSet({\"a.b.c\": grainy.const.PERM_READ}) ) # set from dict (allows string permissions) user.grainy_permissions.add_permission_set({\"a.b.c\": \"r\"})","title":"Setting permissions in bulk"},{"location":"examples/#checking-permissions","text":"import grainy.const from django_grainy.util import Permissions user.grainy_permissions.add_permission_set({\"a.b.c\": \"r\"}) # we use the Permissions() wrapper as that allows # us to do repeated permission checks for a user or group # without having requery permissions for each check perms = Permissions(user) perms.check(\"a.b.c\", grainy.const.PERM_READ) # True perms.check(\"a.b.c.d\", grainy.const.PERM_READ) # True perms.check(\"a.b.c.d\", grainy.const.PERM_READ | grainy.const.PERM_UPDATE) # False perms.check(\"z.y.x\", grainy.const.PERM_READ) # False perms.check(\"a.b.c\", \"r\") # True perms.check(\"a.b.c.d\", \"r\") # True perms.check(\"a.b.c.d\", \"ru\") # False perms.check(\"x.y.z\", \"r\") # False # The `explicit` option allows us to require that excplicit # permissions need to exist for a check to succeed, meaning # having permissions to `a.b.c` will not grant permissions # to `a.b.c.d` if `explicit`=True perms.check(\"a.b.c.d\", \"r\", explicit=True) # False","title":"Checking permissions"},{"location":"examples/#custom-permission-holders","text":"Sometimes you want something else than a user or group model to hold permissions - an APIkey implementation for example from django.db import models from django_grainy.models import Permission, PermissionManager class APIKey(models.Model): key = models.CharField(max_length=255) class APIKeyPermission(Permission): # The `grainy_permissions` related name is important # so that we can pass instances of this model to # util.Permissions api_key = models.ForeignKey( APIKey, related_name=\"grainy_permissions\", on_delete=models.CASCADE ) # use the augmented object manager for permission handling objects = PermissionManager() from django_grainy.util import Permissions api_key = APIKey.objects.create(key=\"test\") api_key.grainy_permissions.add_permission(\"a.b.c\", \"r\") perms = Permissions(api_key) assert api_key.check(\"a.b.c\", \"r\")","title":"Custom permission holders"},{"location":"examples/#grainy-models","text":"A django model can be initialized for grainy permissions using the grainy_model decorator. from django.db import models from grainy.decorators import grainy_model # initialize grainy permissions for a model # with automatic namespacing @grainy_model() class TestModelA(models.Model): name = models.CharField(max_length=255) # initialize grainy permissions for a model # with manual namespacing @grainy_model(namespace=\"a.b.c\") class TestModelB(models.Model): name = models.CharField(max_length=255) # initialize grainy permissions for a model # with manual namespacing for both class # and instance namespace @grainy_model( # we want the same base namespace as model b namespace=TestModelB.Grainy.namespace(), # when checking against instances we want to # nest inside b namespace_instance=\"{namespace}.{instance.b.id}.b.{instance.id}\", ) class TestModelC(models.Model): b = models.ForeignKey(TestModelB) Afterwards the model can be used directly to set or check permissions to it from django_grainy.util import Permissions # give user full permissions to model (any instance) user.grainy_permissions.add(TestModelA, \"crud\") # give user full permissions to a specific instance instance = TestModelA.objects.get(id=1) user.grainy_permissions.add(instance, \"crud\") # check user permission on model class perms = Permissions(user) perms.check(TestModelA, \"r\") # True # check user permission on instance perms.check(instance, \"r\") # True # check permissions to the name field perms.check((instance, \"name\"), \"r\") # return all instances of the model according to permissions instances = perms.instances(TestModelA, \"r\") # this could also take a queryset instances_from_qset = perms.instances(TestModelA.objects.filter(id__gt=10), \"r\") In the grainy_model decorator you can also specify if you want grainy to treat the model as a child of another grainy model by using the parent parameter. This allows you to quickly chain namespaces with the child getting it's namespace prefixed with the parent's namespace # starting with 1.7 you can also use the `parent` argument # to quickly setup namespace inheritance for models @grainy_model(namespace=\"x\") class ModelX(ModelA): pass # We set parent to `x`, to indicate that we want to inherit # the namespacing from there. It needs to point to ForeignKey or OneToOne # field on the model that points to a model that is also grainy (ModelX # in this example) # # ModelY will end up with the following instance namespace: # \"x.{x.pk}.custom.{pk}\" @grainy_model(namespace=\"custom\", parent=\"x\") class ModelY(ModelA): # field name == grainy `parent` value x = models.ForeignKey(ModelX, related_name=\"y\", on_delete=models.CASCADE) # ModelZ will end up with the following instance namespace: # \"x.{y.x.pk}.custom.{y.pk}.z.{pk}\" @grainy_model(namespace=\"z\", parent=\"y\") class ModelZ(ModelA): # field name == grainy `parent` value y = models.ForeignKey(ModelY, related_name=\"z\", on_delete=models.CASCADE)","title":"Grainy Models"},{"location":"examples/#grainy-views","text":"A django view can be initialized for grainy permissions using the grainy_view decorator. When a view is made grainy it will automatically check for apropriate permissions to the specified namespace depending on the request method. from django.views import View as BaseView from django_grainy.decorators import grainy_view # grainy function view @grainy_view(namespace=\"a.b.c\") def view(request): return HttpResponse() # grainy class view @grainy_view(namespace=\"a.b.c\") class View(BaseView): # will check for READ perms to \"a.b.c\", otherwise fails with 403 def get(self, request): return HttpResonse() # will check for CREATE perms to \"a.b.c\", otherwise fails with 403 def post(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 def put(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 def patch(self, request): return HttpResponse() # will check for DELETE perms to \"a.b.c\", otherwise fails with 403 def delete(self, request): return HttpResponse() # grainy view with formatted namespace @grainy_view(namespace=\"detail.{id}\") def detail_view(request, id): return HttpResponse() # you can also pass through flags for permissions checks @grainy_view( namespace=\"detail.{id}\", # require that the user has explicitly set permissions for the namespace explicit=True, # ignore the user's superuser priviledges ignore_grant_all=True, ) def detail_view(request, id): return HttpResponse()","title":"Grainy views"},{"location":"examples/#manually-decorate-view-response-handlers","text":"The grainy_view decorator simply calls the apropriate response decorator on all the response handlers in the view. It follows that from django.views import BaseView from django_grainy.decorators import grainy_view # grainy class view @grainy_view(namespace=\"a.b.c\") class View(BaseView): # will check for READ perms to \"a.b.c\", otherwise fails with 403 def get(self, request): return HttpResonse() # will check for CREATE perms to \"a.b.c\", otherwise fails with 403 def post(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 def put(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 def patch(self, request): return HttpResponse() # will check for DELETE perms to \"a.b.c\", otherwise fails with 403 def delete(self, request): return HttpResponse() is the same as from django.views import BaseView from django_grainy.decorators import grainy_view_response # grainy class view class View(BaseView): # will check for READ perms to \"a.b.c\", otherwise fails with 403 @grainy_view_response(namespace=\"a.b.c\") def get(self, request): return HttpResonse() # will check for CREATE perms to \"a.b.c\", otherwise fails with 403 @grainy_view_response(namespace=\"a.b.c\") def post(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 @grainy_view_response(namespace=\"a.b.c\") def put(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 @grainy_view_response(namespace=\"a.b.c\") def patch(self, request): return HttpResponse() # will check for DELETE perms to \"a.b.c\", otherwise fails with 403 @grainy_view_response(namespace=\"a.b.c\") def delete(self, request): return HttpResponse() You may also use both decorators from django.views import BaseView from django_grainy.decorators import grainy_view, grainy_view_response # grainy class view @grainy_view(namespace=\"a.b.c\") class View(BaseView): # will check for READ perms to \"a.b.c\", otherwise fails with 403 def get(self, request): return HttpResonse() # will check for CREATE perms to \"x.y.z\", otherwise fails with 403 @grainy_view_response(namespace=\"x.y.z\") def post(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 def put(self, request): return HttpResponse() # will check for UPDATE perms to \"a.b.c\", otherwise fails with 403 def patch(self, request): return HttpResponse() # will check for DELETE perms to \"a.b.c\", otherwise fails with 403 def delete(self, request): return HttpResponse()","title":"Manually decorate view response handlers"},{"location":"examples/#rest-framework-integration","text":"Use the grainy_rest_viewset decorator to apply grainy permissions to the output of a django_rest_framework ViewSet. This means any content that the user does not have permission to view will be dropped from the api response. from rest_framework import serializers from django_grainy.decorators import grainy_rest_viewset from .models import TestModelA # A serializer to test with class ModelASerializer(serializers.HyperlinkedModelSerializer): # to test applying of permissions in nested data nested_dict = serializers.SerializerMethodField(required=False) class Meta: model = TestModelA fields = (\"name\", \"id\", \"nested_dict\") def get_nested_dict(self, obj): return {\"secret\": {\"hidden\": \"data\"}, \"something\": \"public\"} @grainy_rest_viewset( namespace=\"api.a\", handlers={ # with application handlers we can tell grainy that this # namespace needs to have explicit permissions in order # to be accessed \"nested_dict.secret\": {\"explicit\": True} }, ) class ModelAViewSet(viewsets.ModelViewSet): queryset = TestModelA.objects.all() serializer_class = ModelASerializer A user with READ permissions to api.a accessing this rest viewset would get this response [{\"name\":\"Test model 1\",\"id\":1,\"nested_dict\":{\"something\":\"public\"}}] While a user with READ permissions to api.a and READ permissions to api.a.*.nested_dict.secret would get this response [{\"name\":\"Test model 1\",\"id\":1,\"nested_dict\":{\"secret\":{\"hidden\":\"data\"},\"something\":\"public\"}}]","title":"Rest Framework Integration"},{"location":"examples/#remote-permission-provider","text":"This functionality is still a work in progress and subject to change. Here is a quick and dirty example on how to set up a django project to be a remote grainy permission provider for another django project.","title":"Remote permission provider"},{"location":"examples/#provider","text":"Set up the grainy endpoints on the grainy permission provider instance from django_grainy.remote import Authenticator, ProvideGet, ProvideLoad class GrainyRequestAuthenticator(Authenticator): def authenticate(self, request): # pseudo-code for handling a token authentication handle_token_authentication(request) urlpatterns += [ # grainy path( \"grainy/get/<str:namespace>/\", ProvideGet.as_view(authenticator_cls=GrainyRequestAuthenticator), name=\"grainy-get\", ), path( \"grainy/load/\", ProvideLoad.as_view(authenticator_cls=GrainyRequestAuthenticator), name=\"grainy-load\", ), ] For the sake of this example it is assumed that the provider instance runs at localhost:8000","title":"provider"},{"location":"examples/#receiver","text":"In order to correctly setup authentication from the receiver django instance the provider django instance you will want to implement an authentication protocol. In this example we go with a straight forward token authentication. Note that the actual authentication logic is omitted as that is not really in the scope of this example. from django.conf import settings import django_grainy.remote class RemotePermissions(django_grainy.remote.Permissions): def __init__(self, obj): super().__init__( obj, url_load=\"http://localhost:8000/grainy/load\", url_get=\"http://localhost:8000/grainy/get\", ) def prepare_request(self, params, headers): try: key = self.obj.key_set.first().key headers.update(Authorization=f\"token {key}\") except AttributeError: pass Then use it like you would the normal Permissions util perms = RemotePermissions(user) perms.check(\"a.b.c\", PREAM_READ)","title":"receiver"},{"location":"install/","text":"Install Install django-grainy into your python env using pip pip install django-grainy Django Setup Open your django settings.py and make the following additions Add to INSTALLED_APPS INSTALLED_APPS = [ ... django_grainy ] Add to AUTHETINCATION_BACKENDS Note : If you have other backends you use they may give permissions to things that grainy cannot control as django only needs one of the installed backends to grant permissions for a permission check complete successfully. The django-grainy backend extends the django.contrib.auth.backends.ModelBackend class AUTHENTICATION_BACKENDS = [\"django_grainy.backends.GrainyBackend\"] Run migrations Create the django-grainy database tables python manage.py migrate","title":"Install"},{"location":"install/#install","text":"Install django-grainy into your python env using pip pip install django-grainy","title":"Install"},{"location":"install/#django-setup","text":"Open your django settings.py and make the following additions","title":"Django Setup"},{"location":"install/#add-to-installed_apps","text":"INSTALLED_APPS = [ ... django_grainy ]","title":"Add to INSTALLED_APPS"},{"location":"install/#add-to-authetincation_backends","text":"Note : If you have other backends you use they may give permissions to things that grainy cannot control as django only needs one of the installed backends to grant permissions for a permission check complete successfully. The django-grainy backend extends the django.contrib.auth.backends.ModelBackend class AUTHENTICATION_BACKENDS = [\"django_grainy.backends.GrainyBackend\"]","title":"Add to AUTHETINCATION_BACKENDS"},{"location":"install/#run-migrations","text":"Create the django-grainy database tables python manage.py migrate","title":"Run migrations"},{"location":"settings/","text":"GRAINY_ADMIN_REMOVE_DEFAULT_FORMS If true the forms for vanilla django permissions will be removed from the admin UI default : True GRAINY_ANONYMOUS_PERMS Allows you to specify a set of permissions for AnonymousUser instances. GRAINY_ANONYMOUS_PERMS = { \"a.b.c\" : grainy.const.PERM_READ } default GRAINY_ANONYMOUS_PERMS = {} GRAINY_ANONYMOUS_GROUP Can be set to a user group name. AnonymousUser permissions will be augmented with permissions from that specified group. default GRAINY_ANONYMOUS_GROUP = None GRAINY_DJANGO_OP_TO_FLAG dict used to convert a django admin operation to a grainy permission flag default GRAINY_DJANGO_OP_TO_FLAG = { \"add\": grainy.const.PERM_CREATE, \"delete\": grainy.const.PERM_DELETE, \"change\": grainy.const.PERM_UPDATE, \"view\": grainy.const.PERM_READ, } GRAINY_PERM_CHOICES A list describing the possible permission flags default import grainy.const GRAINY_PERM_CHOICES = [ # (bitmask flag, verbose name, string flag) (grainy.const.PERM_CREATE, _(\"Create\"), \"c\"), (grainy.const.PERM_READ, _(\"Read\"), \"r\"), (grainy.const.PERM_UPDATE, _(\"Update\"), \"u\"), (grainy.const.PERM_DELETE, _(\"Delete\"), \"d\"), ] django-grainy comes with two predefined permission setups that you can use. predefined shortcuts GRAINY_PERM_CHOICES = ( django_grainy.const.PERM_CHOICES_CRUD ) # Create / Read / Update / Delete GRAINY_PERM_CHOICES = django_grainy.const.PERM_CHOICES_RW # Read / Write GRAINY_REQUEST_METHOD_TO_FLAG dict used to convert a request method to a grainy permission flag default : GRAINY_REQUEST_METHOD_TO_FLAG = getattr(settings, \"GRAINY_REQUEST_METHOD_TO_FLAG\", { \"HEAD\" : grainy.const.PERM_READ, \"OPTIONS\" : grainy.const.PERM_READ, \"GET\" : grainy.const.PERM_READ, \"PUT\" : grainy.const.PERM_UPDATE, \"PATCH\" : grainy.const.PERM_UPDATE, \"POST\" : grainy.const.PERM_CREATE, \"DELETE\" : grainy.const.PERM_DELETE, })","title":"Settings"},{"location":"settings/#grainy_admin_remove_default_forms","text":"If true the forms for vanilla django permissions will be removed from the admin UI default : True","title":"GRAINY_ADMIN_REMOVE_DEFAULT_FORMS"},{"location":"settings/#grainy_anonymous_perms","text":"Allows you to specify a set of permissions for AnonymousUser instances. GRAINY_ANONYMOUS_PERMS = { \"a.b.c\" : grainy.const.PERM_READ } default GRAINY_ANONYMOUS_PERMS = {}","title":"GRAINY_ANONYMOUS_PERMS"},{"location":"settings/#grainy_anonymous_group","text":"Can be set to a user group name. AnonymousUser permissions will be augmented with permissions from that specified group. default GRAINY_ANONYMOUS_GROUP = None","title":"GRAINY_ANONYMOUS_GROUP"},{"location":"settings/#grainy_django_op_to_flag","text":"dict used to convert a django admin operation to a grainy permission flag default GRAINY_DJANGO_OP_TO_FLAG = { \"add\": grainy.const.PERM_CREATE, \"delete\": grainy.const.PERM_DELETE, \"change\": grainy.const.PERM_UPDATE, \"view\": grainy.const.PERM_READ, }","title":"GRAINY_DJANGO_OP_TO_FLAG"},{"location":"settings/#grainy_perm_choices","text":"A list describing the possible permission flags default import grainy.const GRAINY_PERM_CHOICES = [ # (bitmask flag, verbose name, string flag) (grainy.const.PERM_CREATE, _(\"Create\"), \"c\"), (grainy.const.PERM_READ, _(\"Read\"), \"r\"), (grainy.const.PERM_UPDATE, _(\"Update\"), \"u\"), (grainy.const.PERM_DELETE, _(\"Delete\"), \"d\"), ] django-grainy comes with two predefined permission setups that you can use. predefined shortcuts GRAINY_PERM_CHOICES = ( django_grainy.const.PERM_CHOICES_CRUD ) # Create / Read / Update / Delete GRAINY_PERM_CHOICES = django_grainy.const.PERM_CHOICES_RW # Read / Write","title":"GRAINY_PERM_CHOICES"},{"location":"settings/#grainy_request_method_to_flag","text":"dict used to convert a request method to a grainy permission flag default : GRAINY_REQUEST_METHOD_TO_FLAG = getattr(settings, \"GRAINY_REQUEST_METHOD_TO_FLAG\", { \"HEAD\" : grainy.const.PERM_READ, \"OPTIONS\" : grainy.const.PERM_READ, \"GET\" : grainy.const.PERM_READ, \"PUT\" : grainy.const.PERM_UPDATE, \"PATCH\" : grainy.const.PERM_UPDATE, \"POST\" : grainy.const.PERM_CREATE, \"DELETE\" : grainy.const.PERM_DELETE, })","title":"GRAINY_REQUEST_METHOD_TO_FLAG"}]}